## 回溯法


### 解决的问题
+ 组合问题：N个数里面按一定规则找出k个数的集合
+ 切割问题：一个字符串按一定规则有几种切割方式
+ 子集问题：一个N个数的集合里有多少符合条件的子集
+ 排列问题：N个数按一定规则全排列，有几种排列方式
+ 棋盘问题：N皇后，解数独等等

组合是不强调元素顺序的，排列是强调元素顺序的

### 回溯函数模板返回值以及参数
一般起名为backtracking，一般返回值为void

参数：因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般先写逻辑，然后需要什么参数，就填什么参数

伪代码如下
```cpp
void backtracking(参数)
```

### 回溯函数终止条件
既然是树形结构，就一定有终止条件，所以回溯也要有终止条件
什么时候达到终止条件，树中就可以看出，一般来说搜到叶子节点了，也就是找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归

终止条件的伪代码
```cpp
if (终止条件){
    存放结果;
    return;
}
```

### 回溯搜索的遍历过程
回溯法一般是在集合中递归搜索，集合的大小构成树的宽度，递归的深度构成树的深度

![回溯](https://camo.githubusercontent.com/f65ca647f31913496481cd1aff144040bd7ee4f6bc30accd370bc78b4b265d13/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303133303137333633313137342e706e67)

注意图中，举例集合大小和孩子的数量是相等的

回溯遍历过程的伪代码
```cpp
for(选择: 本层集合中元素(树中节点孩子的数量就是集合的大小)){
    处理节点;
    backtracking(路径，选择列表); //递归
    回溯，撤销处理结果
}
```

for循环就是遍历集合区间，可以理解为一个节点有多少个孩子，这个for循环就执行多少次

backtracking这里自己调用自己，实现递归

从图中可以看出，for循环可以理解是横向遍历，backtracking(递归)就是纵向遍历，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找其中一个结果了

以上分析完，可以总结出回溯算法的模板框架
```cpp
void backtracking(参数){
    if (终止条件){
        存放结果;
        return;
    }

    for(选择: 本层集合中元素(树中节点孩子的数量就是集合的大小)){
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

